---
title: State Management의 4단계
categories: [웹개발]
tags: [웹]
comments: false
---

## 동기

최근 리액트 스터디를 준비하면서, Vanilla.js로 어디까지 State Management를 할 수 있는지 궁금했다.

그래서, State Management의 단계를 한번 Vanilla.js로 구현해보기로 했다!

## 상태란?

- 상태는 그 어플리케이션이 현재 담고 있는 정보를 이야기한다.
- 예를 들어, Todo App에서 상태에 해당하는 부분은 다음과 같이 투두 목록이 될 것이다.

```json
{
  "todos": [
    {
      "id": 1,
      "content": "집안일하기",
      "completed": false
    },
    {
      "id": 2,
      "content": "과제하기",
      "completed": true
    }
  ]
}
```

## 상태 관리의 필요성

- 프론트엔드 어플리케이션의 UI는 결국 state를 rendering한 결과물이라고 할 수 있다.

  $$UI = render(state)$$

- 이처럼, State와 View를 분리하고, View는 State가 변할 때마다 자동으로 State를 반영하여 동기화되어야 한다.
- Reactive하다는 뜻은 State의 변화에 따라서 View도 자동적으로 업데이트된다는 점이다.

## 상태 관리의 4단계

1. **Stateless**: State와 View를 따로 분리하지 않고, View에 어플리케이션 데이터가 포함되어 있다.
2. **Mutable State**: State를 Object 혹은 Array로 분리하여 관리하나, 상태를 업데이트 할 때는 State 직접 객체를 수정하고 수동으로 `render()`를 호출한다.

## 템플릿

간단한 투두 리스트를 만들었다. 아래와 같이 HTML 코드를 작성하였다.

```html
<div id="root">
  <input id="todo-input" type="text" />
  <button id="add-todo" type="button">추가하기</button>
  <ul id="todo-list"></ul>
</div>
```

`document.querySelector()`를 매번 작성하기 귀찮아 아래와 같이 동일한 기능을 하는 함수를 만들었다.

```javascript
function $(selector) {
  return document.querySelector(selector);
}
```

### 1. Stateless

```javascript
$("#add-todo").addEventListener("click", () => {
  const todo = $("#todo-input").value;
  const todoList = $("#todo-list");

  // Construct new Element
  const todoElement = document.createElement("li");
  todoElement.innerText = todo;
  todoElement.addEventListener("click", (event) => {
    event.target.remove();
  });

  // Add element to todoList
  todoList.appendChild(todoElement);
});
```

#### 구현

- State를 따로 `let todos = ['집안일하기', '과제하기']`로 분리하지 않았다.
- 대신, '추가하기' 버튼을 누를 때마다 그때그때 Element를 생성해서 `#todo-list` Element의 Child로 추가했다.
- 추가된 Todo Element는 `click`이벤트에 event listener를 추가하여 누르면 해당 Element가 삭제되도록 하였다.

<div id="root" style="text-align: center" >
  <input id="todo-input" type="text" />
  <button id="add-todo" type="button">추가하기</button>
  <ul id="todo-list"></ul>
</div>

<script>
  document.querySelector("#add-todo").addEventListener("click", () => {
  const todo = document.querySelector("#todo-input").value;
  const todoList = document.querySelector("#todo-list");
  // Construct new Element
  const todoElement = document.createElement("div");
  todoElement.innerText = todo;
  todoElement.addEventListener("click", (event) => {
    event.target.remove();
  });

  // Add element to todoList
  todoList.appendChild(todoElement);
});
</script>

#### 단점

- 그러나, 이와 같은 방식은 어플리케이션의 현재 상태를 View에 저장하기 때문에, Data를 이용한 작업(저장하기, 백엔드에서 데이터 받아오기, POST 요청 보내기)를 하기 어렵다

### 2. Mutable State

```javascript
let state = [];

// Event Listeners
function handleAddClick(event) {
  const todo = $("#todo-input").value;
  state.push(todo);
  render(state);
}

function handleRemoveClick(event) {
  const todo = event.target.innerText;
  state.splice(state.indexOf(todo), 1);
  render(state);
}

// Attach Event Listeners
$("#add-todo").addEventListener("click", handleAddClick);

// Synchronize View with State(render)
function render(state) {
  const todoListElement = $("#todo-list");
  todoListElement.innerHTML = "";
  for (let todo of state) {
    const todoElement = document.createElement("li");
    todoElement.innerHTML = todo;
    todoElement.addEventListener("click", handleRemoveClick);
    todoListElement.appendChild(todoElement);
  }
}
```

#### 구현

- State를 `let state = []`를 통하여 분리하였으며, $$UI=render(state)$$의 패턴을 반영하기 위해 `render()`라는 function을 만들었다.
- 발생하는 Event마다 DOM을 짜는 코드를 넣는 것이 아니라, state를 변경하고 이를 기반으로 render를 통해서 화면을 그리기 때문에 상태 업데이트 시 코드의 일관성을 유지할 수 있다.

#### 단점

- 직접 state 객체를 참조 및 수정하게 된다.
- state를 변경할 때마다 **수동으로 render함수를 호출하여 View와 State를 동기화**하였다.

(완성된 바닐라 자바스크립트)

<div style="display: flex; align-items: center; justify-content: center;">
<iframe src="https://vanilla-answer.vercel.app/" style="border: none; box-shadow: 0 0 10px rgba(0,0,0,0.25); width: 350px; height: 600px; text-align: center;"></iframe>
</div>
